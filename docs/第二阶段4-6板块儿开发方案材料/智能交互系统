# æ™ºèƒ½äº¤äº’ç³»ç»Ÿ

*æ–‡ä»¶ä½ç½®: `src/simple_tools/utils/smart_interactive.py`*
*é¢„è®¡ä»£ç é‡: ~100è¡Œ*

## ç³»ç»Ÿæ¦‚è¿°

åˆ©ç”¨ Pydantic v2 çš„æ¨¡å‹éªŒè¯å’Œ Python 3.13 çš„ç±»å‹ç³»ç»Ÿï¼Œæ„å»ºä¸€ä¸ªæ™ºèƒ½ã€å‹å¥½çš„ç”¨æˆ·äº¤äº’ç³»ç»Ÿã€‚

## æ ¸å¿ƒåŠŸèƒ½

1. **å¢å¼ºç¡®è®¤å¯¹è¯** - æ˜¾ç¤ºæ“ä½œé¢„è§ˆå’Œé£é™©æç¤º
2. **æ™ºèƒ½å‘½ä»¤å»ºè®®** - åŸºäºç›¸ä¼¼åº¦åŒ¹é…æä¾›å»ºè®®
3. **æ“ä½œå†å²è®°å½•** - ç®€å•çš„ JSON å†å²è®°å½•
4. **ä¸Šä¸‹æ–‡æ„ŸçŸ¥æç¤º** - æ ¹æ®æ“ä½œç±»å‹æä¾›ç›¸å…³å¸®åŠ©

## å®ç°ä»£ç 

```python
"""æ™ºèƒ½äº¤äº’ç³»ç»Ÿ - åˆ©ç”¨ç°ä»£ Python å’Œ Pydantic ç‰¹æ€§"""

from typing import Any, Optional, TypeVar
from pathlib import Path
from difflib import get_close_matches
import json
from datetime import datetime
from pydantic import BaseModel, Field, computed_field
import click
import logfire


T = TypeVar('T')


class ConfirmConfig(BaseModel):
    """ç¡®è®¤å¯¹è¯æ¡†é…ç½®"""
    operation: str = Field(..., description="æ“ä½œæè¿°")
    item_count: int = Field(..., description="æ“ä½œé¡¹ç›®æ•°é‡")
    dangerous: bool = Field(False, description="æ˜¯å¦ä¸ºå±é™©æ“ä½œ")
    preview_items: list[Any] = Field(default_factory=list, description="é¢„è§ˆé¡¹ç›®")
    max_preview: int = Field(5, description="æœ€å¤§é¢„è§ˆæ•°é‡")

    @computed_field
    @property
    def risk_level(self) -> str:
        """è®¡ç®—é£é™©ç­‰çº§"""
        if self.dangerous:
            return "é«˜"
        elif self.item_count > 100:
            return "ä¸­"
        else:
            return "ä½"

    @computed_field
    @property
    def default_choice(self) -> bool:
        """åŸºäºé£é™©ç­‰çº§çš„é»˜è®¤é€‰æ‹©"""
        return self.risk_level == "ä½"


def smart_confirm(
    operation: str,
    items: list[Any],
    dangerous: bool = False,
    format_item: Optional[callable] = None
) -> bool:
    """æ™ºèƒ½ç¡®è®¤å¯¹è¯æ¡†"""
    config = ConfirmConfig(
        operation=operation,
        item_count=len(items),
        dangerous=dangerous,
        preview_items=items[:5]
    )

    # æ˜¾ç¤ºæ“ä½œæ¦‚è¦
    click.echo(f"\nğŸ“‹ å³å°†{operation} {config.item_count} ä¸ªé¡¹ç›®")

    # é£é™©æç¤º
    risk_icons = {"ä½": "âœ…", "ä¸­": "âš ï¸", "é«˜": "âŒ"}
    risk_colors = {"ä½": "green", "ä¸­": "yellow", "é«˜": "red"}
    click.echo(
        click.style(
            f"{risk_icons[config.risk_level]} é£é™©ç­‰çº§: {config.risk_level}",
            fg=risk_colors[config.risk_level]
        )
    )

    # æ˜¾ç¤ºé¢„è§ˆ
    if config.preview_items:
        click.echo(f"\né¢„è§ˆï¼ˆå‰ {len(config.preview_items)} é¡¹ï¼‰ï¼š")
        for item in config.preview_items:
            if format_item:
                display = format_item(item)
            else:
                display = str(item)
            click.echo(f"  â€¢ {display}")

        if config.item_count > config.max_preview:
            click.echo(f"  ... è¿˜æœ‰ {config.item_count - config.max_preview} é¡¹")

    # å±é™©æ“ä½œç‰¹æ®Šæç¤º
    if config.dangerous:
        click.echo(
            click.style("\nâš ï¸  æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼Œè¯·è°¨æ…ç¡®è®¤ï¼", fg="yellow", bold=True)
        )

    # è®°å½•åˆ° Logfire
    with logfire.span("user_confirm", attributes={
        "operation": operation,
        "item_count": config.item_count,
        "risk_level": config.risk_level
    }) as span:
        # ç¡®è®¤æç¤º
        result = click.confirm(
            f"\nç¡®è®¤{operation}ï¼Ÿ",
            default=config.default_choice
        )
        span.set_attribute("confirmed", result)

    return result


class CommandSuggester:
    """å‘½ä»¤å»ºè®®å™¨"""

    def __init__(self):
        self.commands = {
            "list": {
                "description": "åˆ—å‡ºç›®å½•æ–‡ä»¶",
                "example": "tools list ~/Documents --all",
                "aliases": ["ls", "dir", "show"]
            },
            "duplicates": {
                "description": "æŸ¥æ‰¾é‡å¤æ–‡ä»¶",
                "example": "tools duplicates . --recursive",
                "aliases": ["dup", "find-duplicates"]
            },
            "rename": {
                "description": "æ‰¹é‡é‡å‘½åæ–‡ä»¶",
                "example": "tools rename 'old:new' --path .",
                "aliases": ["mv", "move", "batch-rename"]
            },
            "replace": {
                "description": "æ‰¹é‡æ›¿æ¢æ–‡æœ¬",
                "example": "tools replace 'TODO:DONE' -f file.txt",
                "aliases": ["sed", "substitute", "find-replace"]
            },
            "organize": {
                "description": "è‡ªåŠ¨æ•´ç†æ–‡ä»¶",
                "example": "tools organize ~/Downloads --mode type",
                "aliases": ["sort", "cleanup", "tidy"]
            }
        }

    def suggest(self, user_input: str) -> Optional[dict[str, Any]]:
        """æ ¹æ®ç”¨æˆ·è¾“å…¥æä¾›å‘½ä»¤å»ºè®®"""
        user_input = user_input.lower().strip()

        # ç›´æ¥åŒ¹é…
        if user_input in self.commands:
            return self.commands[user_input]

        # åˆ«ååŒ¹é…
        for cmd, info in self.commands.items():
            if user_input in info["aliases"]:
                return {"command": cmd, **info}

        # æ¨¡ç³ŠåŒ¹é…
        all_names = list(self.commands.keys())
        for info in self.commands.values():
            all_names.extend(info["aliases"])

        matches = get_close_matches(user_input, all_names, n=1, cutoff=0.6)
        if matches:
            match = matches[0]
            # æ‰¾åˆ°å¯¹åº”çš„å‘½ä»¤
            for cmd, info in self.commands.items():
                if match == cmd or match in info["aliases"]:
                    return {"command": cmd, "suggested": True, **info}

        return None

    def show_help(self, command: str, error_msg: str = ""):
        """æ˜¾ç¤ºå‘½ä»¤å¸®åŠ©ä¿¡æ¯"""
        if error_msg:
            click.echo(f"\nâŒ {error_msg}")

        suggestion = self.suggest(command)
        if suggestion:
            if suggestion.get("suggested"):
                click.echo(f"\nğŸ’¡ æ‚¨æ˜¯å¦æƒ³è¦ä½¿ç”¨ '{suggestion['command']}' å‘½ä»¤ï¼Ÿ")

            click.echo(f"\nğŸ“– {suggestion['description']}")
            click.echo(f"ç¤ºä¾‹: {suggestion['example']}")
        else:
            click.echo("\nğŸ’¡ å¯ç”¨å‘½ä»¤:")
            for cmd, info in self.commands.items():
                click.echo(f"  â€¢ {cmd}: {info['description']}")


class OperationHistory:
    """æ“ä½œå†å²è®°å½• - ç®€å•å®ç°"""

    def __init__(self):
        self.history_file = Path.home() / ".simple-tools" / "history.json"
        self.history_file.parent.mkdir(exist_ok=True)
        self.max_records = 100

    def add(self, command: str, args: dict[str, Any], result: dict[str, Any]):
        """æ·»åŠ å†å²è®°å½•"""
        record = {
            "timestamp": datetime.now().isoformat(),
            "command": command,
            "args": args,
            "result": result
        }

        # åŠ è½½ç°æœ‰å†å²
        history = self._load()
        history.append(record)

        # ä¿ç•™æœ€è¿‘çš„è®°å½•
        if len(history) > self.max_records:
            history = history[-self.max_records:]

        # ä¿å­˜
        self._save(history)

        # è®°å½•åˆ° Logfire
        logfire.info(
            f"æ“ä½œè®°å½•: {command}",
            attributes={"command": command, "args": args}
        )

    def get_recent(self, count: int = 10) -> list[dict[str, Any]]:
        """è·å–æœ€è¿‘çš„æ“ä½œè®°å½•"""
        history = self._load()
        return history[-count:] if history else []

    def show_recent(self, count: int = 10):
        """æ˜¾ç¤ºæœ€è¿‘çš„æ“ä½œè®°å½•"""
        records = self.get_recent(count)

        if not records:
            click.echo("æš‚æ— æ“ä½œè®°å½•")
            return

        click.echo(f"\nğŸ“œ æœ€è¿‘ {len(records)} æ¡æ“ä½œè®°å½•ï¼š")
        for i, record in enumerate(records, 1):
            timestamp = datetime.fromisoformat(record["timestamp"])
            time_str = timestamp.strftime("%Y-%m-%d %H:%M:%S")
            click.echo(f"\n{i}. [{time_str}] {record['command']}")
            if record.get("args"):
                click.echo(f"   å‚æ•°: {record['args']}")
            if record.get("result"):
                click.echo(f"   ç»“æœ: {record['result']}")

    def _load(self) -> list[dict[str, Any]]:
        """åŠ è½½å†å²è®°å½•"""
        if not self.history_file.exists():
            return []

        try:
            with open(self.history_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception:
            return []

    def _save(self, history: list[dict[str, Any]]):
        """ä¿å­˜å†å²è®°å½•"""
        with open(self.history_file, 'w', encoding='utf-8') as f:
            json.dump(history, f, ensure_ascii=False, indent=2)


# å…¨å±€å®ä¾‹
command_suggester = CommandSuggester()
operation_history = OperationHistory()
```

## ä½¿ç”¨ç¤ºä¾‹

### 1. æ™ºèƒ½ç¡®è®¤å¯¹è¯

```python
from simple_tools.utils.smart_interactive import smart_confirm

# æ™®é€šæ“ä½œ
files = ["file1.txt", "file2.txt", "file3.txt"]
if smart_confirm("åˆ é™¤æ–‡ä»¶", files):
    # æ‰§è¡Œåˆ é™¤
    pass

# å±é™©æ“ä½œ
files = ["important.doc", "backup.zip", ...]  # 100+ æ–‡ä»¶
if smart_confirm("æ°¸ä¹…åˆ é™¤æ–‡ä»¶", files, dangerous=True):
    # æ‰§è¡Œåˆ é™¤
    pass
```

### 2. å‘½ä»¤å»ºè®®

```python
from simple_tools.utils.smart_interactive import command_suggester

# åœ¨ CLI é”™è¯¯å¤„ç†ä¸­ä½¿ç”¨
try:
    # æ‰§è¡Œå‘½ä»¤
    pass
except click.UsageError:
    command_suggester.show_help(
        user_command,
        "å‘½ä»¤ä¸å­˜åœ¨"
    )
```

### 3. æ“ä½œå†å²

```python
from simple_tools.utils.smart_interactive import operation_history

# è®°å½•æ“ä½œ
operation_history.add(
    "rename",
    {"pattern": "old:new", "path": "/path/to/files"},
    {"success": 10, "failed": 0}
)

# æ˜¾ç¤ºå†å²
operation_history.show_recent(5)
```

## é›†æˆè¦ç‚¹

1. **ç¡®è®¤å¯¹è¯å¢å¼º** - æ›¿æ¢ç°æœ‰çš„ `click.confirm` è°ƒç”¨
2. **é”™è¯¯æ—¶æä¾›å»ºè®®** - åœ¨å‘½ä»¤é”™è¯¯æ—¶è‡ªåŠ¨æä¾›ç›¸ä¼¼å‘½ä»¤
3. **è®°å½•å…³é”®æ“ä½œ** - åœ¨å·¥å…·æ‰§è¡Œå®Œæˆåè®°å½•ç»“æœ
4. **ä¿æŒç®€å•** - ä¸è¿‡åº¦è®¾è®¡ï¼Œåªæä¾›å¿…è¦åŠŸèƒ½

## é¢„æœŸæ•ˆæœ

- ç”¨æˆ·åœ¨æ‰§è¡Œå±é™©æ“ä½œæ—¶å¾—åˆ°å……åˆ†è­¦å‘Š
- å‘½ä»¤è¾“é”™æ—¶è·å¾—æ™ºèƒ½æç¤º
- å¯ä»¥æŸ¥çœ‹å†å²æ“ä½œè®°å½•
- äº¤äº’ä½“éªŒæ›´åŠ å‹å¥½å’Œæ™ºèƒ½
